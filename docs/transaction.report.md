# 트랜잭션 범위 분석 및 서비스 확장에 따른 서비스 설계 문서

## 1. 서비스 분리 전략

서비스를 도메인에 따라 분리함으로써 각 서비스가 독립적으로 운영되도록 구성했습니다. 이러한 구조는 확장성 및 유지보수성을 높이지만, 동시에 분산 환경에서 트랜잭션 관리가 복잡해진다.

서비스 분리 전략

- `Payment Service`: 결제 요청을 처리하고 결제 상태를 확인.
- `User Service`: 사용자 포인트를 관리하며 포인트 사용 기록.
- `Concert Service`: 콘서트와 좌석의 상태를 관리하며, 좌석 예약 및 상태 업데이트를 담당.
- `Waiting Queue Service`: 콘서트의 좌석 대기열을 관리.

## 2. 트랜잭션 범위 분석 및 문제점

### 1. 좌석 예약

- 트랜잭션 범위: Concert Domain (`seatRepo`, `reservationRepo`, `concertDateRepo`)
- 트랜잭션의 흐름

        1. 좌석 정보 조회 (seatRepo)
        2. 예약 정보 생성 (reservationRepo)
        3. 예약 정보 생성 (reservationRepo)
        4. 예약 정보 생성 (reservationRepo)

- 문제점
  - 하나의 트랜잭션에 여러 기능이 혼재. 트랜잭션 실행 시간과 잠금 시간이 길어져 성능 저하 유발.

### 2. 결제

- 트랜잭션 범위: PaymentDomain (`paymentService`), UserDomain(`userService`, `pointHistoryService`), ConcertDomain(`concertService`,`reservationService`)
- 트랜잭션의 흐름:

        1. 예약 정보 조회 (reservationService)
        2. 포인트 사용 기록(pointHistoryService)
        3. 포인트 차감(userService)
        4. 결제 정보 생성(paymentService)
        5. 좌석 상태 변경(concertService)
        6. 예약 상태 변경(reservationRepo)

- 문제점
  - 여러 도메인에 걸쳐 있으며, 트랜잭션 범위가 넓어질수록 성능 저하와 데이터 불일치 위험이 높아진다.

### 3. 포인트 충전

- 트랜잭션 범위 :UserDomain(`userService`, `pointHistoryService`)
- 트랜잭션의 흐름:

        1. 포인트 충전(userService)
        2. 포인트 충전 기록 생성(pointHistoryService)

## 3. 분산 트랜잭션과 문제점

```
여러 서비스나 데이터베이스에 걸쳐 트랜잭션이 일관성을 유지하면서 동시에 처리되어야 할 때 사용되는 기법. 분산 트랜잭션은 여러 시스템 간의 데이터 변경을 하나의 논리적인 트랜잭션으로 묶어, 모든 변경이 성공적으로 완료되거나 모든 변경이 취소(롤백)되도록 보장한다.
```

- 데이터 일관성 문제: 네트워크 문제나 서비스 중단으로 인해 일부 서비스에서만 데이터 변경이 적용되는 경우, 데이터 일관성을 유지하기 어려워진다.

- 성능 저하: 분산 트랜잭션을 통해 트랜잭션을 관리하면 네트워크 호출이 증가하고, 여러 서비스에서 동시에 데이터를 확인하고 변경하기 때문에 성능이 저하될 수 있다.

## 4. 분산 트랜잭션의 해결 방안

`분산 트랜잭션의 문제를 해결하기 위해 2PC(2-Phase Commit), TCC(Try-Confirm-Cancel), SAGA, Outbox 패턴과 같은 다양한 패턴을 사용할 수 있다.`

### 1. 2단계 커밋(2-Phase Commit, 2PC)

```
2PC는 분산 트랜잭션에서 데이터 일관성을 보장하기 위해 주로 사용되는 방식이다.

1단계(Prepare): 모든 참여 서비스에 준비 요청을 보낸다.

2단계(Commit or Rollback): 모든 서비스가 준비 완료 상태일 때 커밋 명령을 보내며, 실패 시 롤백 명령을 보낸다.
```

### 2. TCC(Try-Confirm-Cancel)

```
TCC는 분산 트랜잭션에서 각 서비스가 준비(Try), 확인(Confirm), 취소(Cancel) 단계로 나누어 자원 예약과 취소를 제어하는 방식이다.

- Try 단계: 자원을 임시로 예약하거나 필요한 상태를 준비
- Confirm 단계: 모든 서비스가 준비되면 트랜잭션을 커밋하여 자원을 확정
- Cancel 단계: 트랜잭션이 실패 시 자원 사용을 취소
```

### 3. SAGA 패턴

```
SAGA 패턴은 각 서비스가 독립적으로 트랜잭션을 처리하도록 하며, 이벤트 기반으로 상태 변화를 전달하여 보상성 작업을 통해 롤백을 구현하는 방식이다.
```

### 4. Outbox 패턴

```
Outbox 패턴은 트랜잭션과 이벤트 발행을 함께 처리하여 이벤트 기반 통신에서 데이터 일관성을 보장하는 방식이다. 데이터베이스에 트랜잭션과 이벤트를 기록하고, 메시지 큐를 통해 이벤트를 전파하여 다른 서비스에 상태 변화를 전달.
```

## 5. 서비스 확장에 따른 설계 방안

### 좌석 예약 서비스에 SAGA 및 Outbox 패턴 적용

- SAGA 패턴: 각 서비스가 좌석 예약 및 업데이트 작업을 독립적으로 처리하고, 각 단계 실패 시 보상 트랜잭션을 실행한다.
- Outbox 패턴: 좌석 예약 성공 시 Outbox에 이벤트를 저장하여, 다른 서비스로 상태 변경을 전달한다.

### 결제 서비스에 TCC와 Outbox 패턴 적용

- TCC 패턴: 자원 예약 및 상태 확정을 위해 결제 트랜잭션에서 TCC를 활용해 자원을 임시 예약하고 최종 결제 시 확정상태로 변경한다.
- Outbox 패턴: 결제가 완료되면 Outbox에 이벤트를 저장하고, 이를 통해 다른 서비스에 상태 변경을 전달한다.

### 포인트 충전 서비스에 SAGA 및 Outbox 패턴 적용

- SAGA 패턴: 충전 완료 후 포인트 사용 기록이 업데이트 되도록 SAGA로 트랜잭션을 분할한다.
- Outbox 패턴: 충전 완료 후 Outbox를 통해 상태 변경 이벤트를 발행하여 다른 서비스와의 데이터 일관성을 유지한다.
